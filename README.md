# Лабораторная работа №1. Численные методы решения нелинейных уравнений
## Вариант 5: Уравнение √(x+1) = 1/x

### Общее описание
Для уравнения **√(x+1) = 1/x** были реализованы три численных метода:
1. Метод простой итерации
2. Модифицированный метод простой итерации  
3. Метод Ньютона

Все методы используют **начальное приближение x₀ = 0.6** и **точность ε = 10⁻⁴**.

---

## Задача 1. Метод простой итерации

### Код и объяснение

**Графическая локализация (graph.m):**
```matlab
x = 0.5:0.01:3;
f = sqrt(x + 1) - 1 ./ x;
plot(x, f, 'LineWidth', 2);
grid on;
hold on;
plot(x, zeros(size(x)), 'k--');
title('График функции f(x) = sqrt(x+1) - 1/x');
xlabel('x');
ylabel('f(x)');
```
*Строит график функции для визуального определения интервала локализации корня [0.6, 0.8]*

**Выбор итерационной функции (graph2.m):**
```matlab
a = 0.6;
b = 0.8;
x = a:0.001:b;

% Все функции
f_x = sqrt(x + 1) - 1 ./ x;          % f(x)
y_zero = zeros(size(x));              % y = 0
y_line = x;                           % y = x
phi1 = 1 ./ sqrt(x + 1);              % φ₁(x)
phi2 = (1 ./ x).^2 - 1;               % φ₂(x)

figure;
plot(x, f_x, 'g', 'LineWidth', 2); hold on;    % f(x) - зелёный
plot(x, y_zero, 'k--', 'LineWidth', 1);        % y = 0 - чёрный пунктир
plot(x, y_line, 'k', 'LineWidth', 2);          % y = x - чёрный
plot(x, phi1, 'r', 'LineWidth', 2);            % φ₁(x) - красный
plot(x, phi2, 'b', 'LineWidth', 2);            % φ₂(x) - синий

grid on;
legend('y = f(x)', 'y = 0', 'y = x', 'y = φ₁(x)', 'y = φ₂(x)');
title('Проверка эквивалентности преобразований');
xlabel('x');
ylabel('y');
```
*Сравнивает две итерационные функции. φ₁(x) пересекает y = x в точке корня*

**Проверка условия сходимости (graph3.m):**
```matlab
a = 0.6; b = 0.8;
x = a:0.001:b;

phi1_deriv = 1 ./ (2 * (x + 1).^(3/2));
phi2_deriv = 2 ./ (x.^3);

plot(x, phi1_deriv, 'b', 'LineWidth', 2);
hold on;
plot(x, phi2_deriv, 'r', 'LineWidth', 2);
plot(x, ones(size(x)), 'k--', 'LineWidth', 2);
grid on;
legend('|φ₁''(x)|', '|φ₂''(x)|', 'y = 1');
title('Проверка условия сходимости');
```
*Показывает, что только |φ₁'(x)| < 1 на интервале [0.6, 0.8]*

**Расчет параметра q (param_q.m):**
```matlab
a = 0.6;
q = abs(-1 / (2 * (a + 1)^(3/2)))
```
*Вычисляет q = max|φ'(x)| = 0.2471 на левом конце интервала*

**Реализация метода (script.m):**
```matlab
phi = @(x) 1 ./ sqrt(x + 1);
epsilon = 1e-4;
a = 0.6; b = 0.8;
q = 0.2471;
epsilon0 = ((1 - q) / q) * epsilon;
x0 = 0.6;

x_prev = x0;
for k = 1:100
    x_next = phi(x_prev);
    diff = abs(x_next - x_prev);
    
    if diff <= epsilon0
        break;
    end
    x_prev = x_next;
end
```
*Реализует итерационный процесс xₖ₊₁ = 1/√(xₖ + 1)*

**Результат:** Сходится за 6 итераций к x ≈ 0.754878

---

## Задача 2. Модифицированный метод простой итерации

### Код и объяснение

**Анализ производной (graph.m):**
```matlab
% Пункт 1: График f'(x) на [a,b]
a = 0.6; b = 0.8;
x = a:0.001:b;

f_prime = @(x) 1./(2*sqrt(x+1)) + 1./(x.^2);
y_prime = f_prime(x);

figure;
plot(x, y_prime, 'b', 'LineWidth', 2);
grid on;
title('График производной f''(x) на интервале [0.6, 0.8]');
xlabel('x');
ylabel('f''(x)');
```
*Показывает, что f'(x) монотонно убывает на [0.6, 0.8]*

**Расчет параметров (step2_3.m):**
```matlab
f_prime = @(x) 1./(2*sqrt(x+1)) + 1./(x.^2);
a = 0.6; b = 0.8;

M = f_prime(a)  
m = f_prime(b)  

alpha = 2 / (M + m)  
q = (M - m) / (M + m)  
```
*Вычисляет оптимальные параметры α и q*

**Реализация метода (script.m):**
```matlab
f = @(x) sqrt(x + 1) - 1 ./ x;
f_prime = @(x) 1./(2*sqrt(x+1)) + 1./(x.^2);

epsilon = 1e-4;
a = 0.6; b = 0.8;
x0 = 0.6;

M = f_prime(a);  
m = f_prime(b);  
alpha = 2 / (M + m);  
q = (M - m) / (M + m);  
epsilon0 = ((1 - q) / q) * epsilon;  

x_prev = x0;
for k = 1:100
    x_next = x_prev - alpha * f(x_prev);
    diff = abs(x_next - x_prev);
    
    if diff <= epsilon0
        break;
    end
    x_prev = x_next;
end
```
*Реализует модифицированную итерацию xₖ₊₁ = xₖ - α·f(xₖ)*

**Результат:** Сходится за 5 итераций к x ≈ 0.754880

---

## Задача 3. Метод Ньютона

### Код и объяснение

**Реализация метода (script.m):**
```matlab
f = @(x) sqrt(x + 1) - 1 ./ x;
f_prime = @(x) 1./(2*sqrt(x+1)) + 1./(x.^2);

epsilon = 1e-4;
x0 = 0.6;

x_prev = x0;
for iter = 1:100
    x_next = x_prev - f(x_prev) / f_prime(x_prev);
    difference = abs(x_next - x_prev);
    
    if difference <= epsilon
        break;
    end
    x_prev = x_next;
end
```
*Реализует классический метод Ньютона xₖ₊₁ = xₖ - f(xₖ)/f'(xₖ)*

**Результат:** Сходится за 4 итерации к x ≈ 0.754878

---

## Сравнение методов

### Результаты встроенной функции fzero:
```matlab
f = @(x) sqrt(x+1) - 1/x;
root = fzero(f, 0.6);  % Результат: x = 0.754878
```

### Сравнительная таблица:
| Метод | Итераций | Корень |
|-------|----------|---------|
| Простая итерация | 6 | 0.754878 |
| Модифицированная итерация | 5 | 0.754880 |
| Метод Ньютона | 4 | 0.754878 |
| fzero | - | 0.754878 |

### Вывод:
Метод Ньютона показал наилучшую скорость сходимости (4 итерации). 
